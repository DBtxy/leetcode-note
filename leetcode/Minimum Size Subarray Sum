最小化子数组求和，这题的基本思路如下：
从当前元素开始，尾指针后移开始求和，如果大于了target，这满足要求，头指针后移，如果还是
大于，头指针继续后移，这里面隐藏的思路是，当和大于target，只能后移头指针，而不是前移尾指针
因为前面的和已经被检测过了


------------------------------------------------------------------------------------
还有一种思路O(nlogn)
先求和，求初始位置到当前位置的和，那么形成了一个有序数组，该数组元素之间的差就是某一段的和，那么先固定
一个位置，然后用这个位置的值加上target，然后二分查找这个值
